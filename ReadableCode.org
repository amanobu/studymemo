*** 1章
- コードは理解しやすくなければならない。
- コードは自分も他人も含め最短期間で理解できるように書かなければならない。
*** 2章
- 単語は明確な物を選ぶ
  - もっと明確な物があるはずだ
  - send:deliver,dispatch,announce,distribute,route
  - find:search,extract,locate,recover
  - start:launch,create,begin,open
  - make:create,setup,build,generate,compose,add,new
  - get:download,fetch
  - filter:select,exclude
- tmp,retval,resultなどの汎用的すぎる変数を使っていないか。
  - 意味を表す物にしよう
  - 何かの計算結果を返す関数の変数なら、retvalよりもsum_squaresとか
  - 本当に変数の入れ替えの為のtmpならtmpでよし。
  - tmpのように汎用的な名前を使うならそれ相応の理由を用意する
  - ループイテレータのiとかjとか
    - それより、何の変数のイテレータか示す名前だとチェックも出来るよね
    - clubsならci,usersならuiとか
- 名前に情報を詰め込んでいるか
  - startよりもstart_msだと、変数の単位が分かったり
- 変数名が長くなるのを恐れて短くしすぎて理解しずらいものになっていないか。
  - スコープが小さいのであれば短い名前でもよし
    - 周りを見ればすぐ把握できるので
  - スコープの大きい変数には長い名前を付けるなどは良い
- 英単語を省略して理解しづらいものになってないか
*** 3章
- 名前が他の意味と間違えられることはないか？ 
- 限界値を示す変数に min_ max_を使っているか。
- 範囲を示す変数に first_ last_を使っているか。
- 包含/排他的範囲にはbegin/end
- bool値にはisやhasを
- getXXXXメソッドをアクセッサー以外で定義していないか。
  - getはアクセサーを連想する為
*** 4章
- インデントが整っており見やすいコードになっているか。
- 一貫性のある並びになっているか
  - コードが意味のある固まり・順序になっているか
    - 意味のある宣言の固まり：構造体の宣言がまとまっている等
*** 5章
- コメントは書き手の意図を読み手に知らせること
- 意味のないコメントを書いていないか。
  - コードから読み取れる事をコメントに書いていないか。
  - ひどいコードに対するコメント：ひどいならコードを直せ
- 考えを記載しているか
  - TODOや、XXX(危険)など
  - 定数の意味・背景
  - コードの背景
- 読み手の立場に立って記載されているか
  - 驚くような動作
  - コードの細部を読まないと分からないことなど
  - クラスの使用方法など高レベルのコメントが必要なファイルには、ファイルの先頭にコメントが書かれているか。
*** 6章
- あれ、これといった代名詞を避けてコメントされているか
- 関数の動作は出来るだけ正確に
- 関数の良く分からない引数は詳細にコメントを
*** 7章
- 条件やループなどの制御フローは出来るだけ自然に分かるようにする事
- 左側：調査対象の式。変化する、右側：比較対象の式。余り変化しない　→　if(length>=10)
- ヨーダ記法つかってない？
- ifブロックの並び順
  - 条件は否定形よりも肯定系が読みやすい:if(!debug)よりもif(debug)
  - 単純な条件を先に
  - 目立つ条件を先に
- コードの行数を短くするよりも理解しやすい物を
  - 三項演算子の複雑な物をさけるなど
- do whileループは避ける
  - 過去の経験上良いとされる傾向があるらしい
- 関数内で早めに処理を返せる物は返しているか
  - 一番最後にreturnしなくてもよい。返せる物はさっさと返すとあと処理を読まなくてすむ
- ネストが深くなってないか
*** 8章
- 説明変数を使って改良できるコードが残っていないか。
  - if(str.split(':')[0].strip()=="root")　よりも
    - username=str.split(':')[0].strip()
    - if(username)
- 要約変数を使って改良できるコードが残っていないか。
  - request.id→何のIDか分からない。よってaccess_allowed_idとかすると何のIDかわかりやすい
  - if(request.id==document.id)...とやるよりも
    - user_owns_document = (request.id==document.id) //idがドキュメントのオーナか
    - として
    - if(user_owns_document)...がわかりやすい
  - ドモルガンの法則でand/or/notを簡単に
- いろんな条件判断・処理を１行で記載されてないか
  - 無駄に複雑にしてないか
    - もっと簡単な判定条件が無いか検討する
  - 巨大な分は分割を検討する
  - 複雑名短絡評価になっていないか？
    - 左側から評価していき、条件にマッチしたら後は評価されない事
    - assert((!bucket = FindBucket(key)) || !bucket->IsOccupied());
      - とか。２行にすればいいじゃん。読みにくい
*** 9章
- 不要な変数を使っていないか
  - ループの中の無駄な中間結果を保持する
  - ループの中の制御変数(これが条件になったらflag=ture)としてループを抜けるとか
    - breakとかでさっさと抜ける
- 変数のスコープは可能な限り縮めているか
- 不要にグローバルスコープの変数を定義していないか
  - javascriptのfor(i = 0; i < 10; i++)とかのiがvarで定義されてないのでグローバルらしい
- 変数の定義を使う直前で定義しているか
  - 不要な変数が把握出来る
  - 現在値の判断が沢山のコードを読まないといけなくなる
- 出来るだけ変数への代入は１回になっているか
  - 多数書き換わるとバグを生む。プリミティブになるべき
  - java等はfinalで定義出来るなら定義する
*** 10章
- メソッドは適切に分割出来ているか
  - 無関係な下位問題を積極的に見つけて分割する
    - プロジェクト固有のコードと汎用的なコードを見つける
    - テストがしやすくなる
    - 再利用しやすくなる
    - 正し分割しすぎると読みにくくなる
*** 11章
- メソッドが一度に複数の事を処理していないか
  - その中で実施している事を列挙してみる
    - すると分割できるものがあるはずだ
*** 12章
- 複雑なコードが簡単に記載or説明されているか
  - 日本語でやることを箇条書きしてみよう
    - 別の解決策が閃くかもしれない
    - 11章と同じようにロジックを分割できるかもしれない
- 処理の説明をうまくできないのであれば、何か見落としているか、処理の詳細が決まってないのかもしれない
*** 13章
- コードを小さく保っているか
  - コードのサイズが大きくなればなるほどそのメンテにかかるコストは多くなる
  - 未使用のコードは削除する
  - 無用な機能は削除する
- 不必要な実装をしていないか
  - 代替ライブラリがないか
  - ※標準APIには慣れておく
*** 14章
- テストコードが一目で何をテストしているかわかる状態か
  - それを表現するためにはhelper関数は使うべき
  - テストの本質だけ.例：順番に呼び出したURLのスコア
    - SortedDocs(0,1,4,1,3) //この順にスコアが出ることのTEST
      - このぐらいまでできればテストの追加が簡単でテストをたくさん書きたくなるでしょ？
- テストケースが簡単に追加できるような状況か
  - CheckScoreBeforeAfter("B,e,f,o,r,e","A,f,t,e,r")
    - このぐらいまで入力値を単純化すれば簡単にケースが追加できるよね
- test関数にも説明的な名前を付け何をテストするのかわかる状況か
