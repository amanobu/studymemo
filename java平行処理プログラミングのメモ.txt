共有オブジェクトを持たないならスレッドセーフ

VMやコンパイラ・プロセッサの見かけ上の順序というのはない。List:3-1のようなのは安全とは限らない

javaのきのうに揮発性変数というのがある。これをつけた変数はVM・コンパイラ・ランタイム的に順序が整理され、取得する際は最新の値を取得する
　→スタータスフラグの用途で使われう。
volatile 変数

スレッドセーフかどうかをドキュメントに書くべきだ

これはスレッドセーフではない。
for (int i=0;i<vector.size();i++){
	do_something(vector.get(i));
→vectorは別の場所でサイズが変わるかもしれない
synchronized(vector){
for (int i=0;i<vector.size();i++){
	do_something(vector.get(i));
}
もしくは。cloneをつくって、それを廻す。
そんな感じで、共有のCollectionをイテレートするときはオブジェクトをロックしないとNG

超細かいことでCollectionクラスをデバッグログで出力するとき、
System.out.println("debug:"+vector)とかやると、これもイテレーションしている。

java.util.concurrent packageにいろんなスレッド調停をおこなう機能が提供されている

ラッチ：最終ステートまで対象のスレッドを進捗を遅らせる。ゲートの開け閉めのようなイメージ
例えば
　・必要なリソースがそろうまで計算を開始させない
　・A,B,Cの完了に依存する処理Sがあるとして、A,B,Cが完了するまでSを開始させない

CountDownLatch:数のカウントでゲートの開け閉めを制御
　→なんか負荷試験の一斉リクエストみたいだ
　→List5-11

似たものにバリヤ（barrier）というものがある。が、ラッチとの違いがよくわからん
ラッチはイベントをまつためにつかう
バリヤは仲間のスレッドを待つためにつかう


FutureTask:分散処理に使えそう


一部のまとめ
・可変にする必要のないものはfinalにせよ
・不可変オブジェクトの共有はスレッドセーフ
・カプセルを適切に実施することで複雑なロックを制御できるようになる
・可変変数はどれもロックでガード
・1つの不変更を構成するためすべての変数を同じロックでガードしろ
・スレッドセーフ性は設計段階から
・同期化のポリシーをドキュメント化しろ


Executorフレームワーク

素のスレッドは
・制限がない。マシンのキャパまではいいが、それ以上はコンテキストスイッチが重い
・よって資源が消費
・最悪資源を食いつぶし、不安定。そしてOUTOFMEMORY

このフレームワークで、
・タスクを実行すること
・実行のされ方
・実行を依頼（VMに）
を分離する：で管理できる

おそらく・・・
スレッドプール（Executorクラスのstaticメソッド)で数を制御
ExecutorServiceインターフェースで停止などの制御


Runnable・Callableはタスクの抽象的な表現だが・・・
→スレッドのライフサイクルを表現するFutureというのもなる
　→タスクの結果をとりだす表現もある
　　→参照：List6-13

CompletionService：ExecutorがBlockingQueueと合体
→タスクの完了結果が取り出せる

JVMはスレッドを強制的に停止する仕組みはない。あるのは協力的な仕組み。
→分かりにくいけど、キャンセルがリクエストされたということをタスクがチェックする方法とか
キャンセルかどうかのフラグを保持する変数はvolatile変数の必要があるらしいがなぜかよくわからない。

でもキャンセルの実装はInterruptedExceptionを投げるのが手っ取り早いList7-5

タスクはキャンセルのポリシーを決めるべき。
つまりInterruptedExceptionを受けた時どのように解釈するか。
タスク（データ）の破壊。中途半端な状態で終わりにならないように


異常終了を扱う。List7-23
想定外の例外を補足した場合、そのまま落ちると何が起きたか全くわからない。
死ぬなら、その例外を回した後で。List7-23のように書いて落ちる

または、
未補足の例外の場合JVMはUncaughtExceptionHandlerを報告する。
それを実装したものがなければSystem.errにはくのがデフォルト
一番多いのは、List7-25のようなｋクラスを実装する

長時間稼働するアプリにはこのUncaughtExceptionHandlerをすべてのスレッドに入れて例外を補足するのが良いらしい



JVMのSHUTDOWN
整然：最後のスレッドがexitしたとき
突然：いつもの

整然と落ちる場合
JVMは複数のシャットダウンフックを呼ぶ。Runtime.addShutdownHookで登録したスレッド
Shutdown Hookはスレッドセーフであるべき。どの順で呼ばれるかわからない。
またSystem.exitをしてはNG


ThreadPoolあたりの話
シングルスレッドExecutorで複数タスクを投げるとLOCKしてしまう話：List8-1
ここまでは実装はしないと思うので読み飛ばすが、List8-7はよさげな実装

並列処理の例：List8-10,11,12
List8-16,17:パズルを並列で解いて、初めに解が見つかったら止める



GUIのはなし。
マルチスレッドGUIは難しすぎて作成できない。できないことはないがすべてのコンポーネントを注意深く設計する必要があり。それをやるのは無理
こんにちのものシングルスレッド。


生存事故の話
List10-1のように循環のものがあると（お互いにほしい）ロックするぜ
List10-2もね。Accountの値の渡し方によって循環する
　List10-3でオブジェクトのハッシュコードをチェックして変な風に渡されないようにしているとか
　　→本当かよ？と思うけど、本では推奨の雰囲気で書かれている

List10-5もわかりにくいけど、syncrhronizedメソッドからsyncrhronizedメソッドを双方を呼び出しているのでロックの可能性。→共有する状態を正しく見極める
→syncrhronizedメソッド使いやすいけど、このような罠に陥りやすい！！！
　→syncrhronizedブロック！！をつかう

デッドロックしている場合ThreadDumpすると分かる場合がある
kill -3　Ctrl-\ WindowsならCtrl-Breakで出力


スケーラビリティの話
※一般的な最適化の話はしない。推測じゃなく計測せよとか
ロックの争奪を減らす：当たり前のはなし
排他ロックに代わるもの：many Read 1 Write
無駄にオブジェクトプールしない。newしたほうが早いときもある。計測計測


テストの話
UnitTestは難しい。
まずはシングルスレッドで動作する際を想定してテストケースを書く。
→もし、並列処理の問題か、それとも違うのかを検証する際に役立つ

ブロックの試験
ブロック成功したら、何とかしてブロックを解くようにする必要がある（テストが進まない）
うまくやる方法は、ブロックしたらInterruptedし、returnするかInterruptedExceptionを投げるか
List12-3
→スレッド作り、適当な時間待ち割り込みをかける。それをキャッチして・・・成功。
→Runnableを使わずThreadのサブクラスを作ったほうがよい数少ない例。正しい終了のテストをするため。ほほー。


安全性の試験：つまり、データが破壊されてないかとかの試験。
凄く難しい。。。

例：プロデューサー・コンシューマのテスト
・入れたものがそこから確実に出ること
・それ以外のものはなにも出てこないこと
みたいなテスト

入れたもの・出したものを別で管理して…みたいなテストコードはよさそうじゃないらしい。（テストスレッドのスケジューリングが歪むでしょう・・・いみわからん）
それよりも、入ったものと出したもののCheckSumがマッチしたらOKというのがよい。CheckSumは順序にも依存するCheckSumである（ある時点で入れたものが、その順で出てきているよね？の確認のため）

また、CheckSumの計算は下手なものを使うとコンパイラに推測されてうまくいかないらしい。
乱数生成はスレッドセーフなので、平行性のテストなのに同期化をもちこんでしまう。List12-4のようなものがいいらしい。各スレッドで違う値になればいいだけなので。
→サンプルList12-5,12-6
一気に処理を走らせるためCyclicBarierを使っている

このようなテストをループを多くし、何回も試せば大丈夫という風に思えてくる

List12-7:資源りーくのテスト。
List12-10:スレッドの切り替えを多くやって確認する方法。Thread.yieldをたくさん呼ぶ

List12-11,12-12,12-13:並列実行性能のテスト
実行性能のテストはGCやJITコンパイラの影響も考える

試験を補完するために
・試験の目的はエラーを発見してくれるというよりも、問題なさそうだという確信を得るため



その他のロック
新しいものが加わっている
ReentrantLock：List-13-2：DBと同じようだ。finallyでLock開放を忘れるな！
tryLockを使えば、ロックができなかったときにプログラムに制御がもどるList13-3,4

synchronizedとReentrantLockの使い分け
ブロックでunlockできるからよいよね。synchronized
デッドロック時にダンプするとReentrantLockはどこかわかりやすいらしい
通常はsynchronizedを使うべき。上記の利点やJVMに備わっている機能なので最適化がきいたりする。

ReadWriteLockというものもある。ReaDが圧倒的に多いという事実から性能が良い


ノンブロッキングアルゴリズム：synchronizedよりも楽観的なロック
ロックの代わりに、compare and swap(比較して入れ替える)
※最近のCPUには並行アクセスの為の特殊な命令をよういしている。JAVA5まではそれを使わなかった
対象の変数の古い値と新しい値を持っている。
更新時に対象が古い値であれば新しい値に変更するということ（この時CPUの機能をつかう）
もし古い値と一致しなかったら失敗の扱いとする。List15-1がサンプル
失敗した場合はもう一度トライするなど



安全な遅延初期化の例：List16-4,16-5
